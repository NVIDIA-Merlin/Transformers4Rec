==================================================================== test session starts =====================================================================
platform linux -- Python 3.8.10, pytest-7.2.0, pluggy-1.0.0
rootdir: /mnt/Transformers4Rec-refactor
plugins: anyio-3.6.2
collected 27 items

test_model.py F..F.........FFFFFFFFFFFFFF                                                                                                              [100%]

========================================================================== FAILURES ==========================================================================
_____________________________________________________________________ test_simple_model ______________________________________________________________________

torch_tabular_features = TabularFeatures(
  (_aggregation): ConcatFeatures()
  (to_merge): ModuleDict(
    (continuous_module): SequentialBlock...eddingBagWrapper(332, 64, mode=mean)
        (user_country): EmbeddingBagWrapper(63, 64, mode=mean)
      )
    )
  )
)
torch_tabular_data = {'categories': tensor([[236,  14, 256,  ...,   0,   0,   0],
        [205,  89,  36,  ...,   0,   0,   0],
        [12... 0.0420, 0.7020,
        0.9199, 0.2935, 0.3351, 0.9686, 0.1185, 0.3018, 0.2741, 0.0442, 0.8873,
        0.9423]), ...}

    def test_simple_model(torch_tabular_features, torch_tabular_data):
        targets = {"target": pytorch.randint(2, (100,)).float()}
    
        inputs = torch_tabular_features
        body = tr.SequentialBlock(inputs, tr.MLPBlock([64]))
        model = tr.BinaryClassificationTask("target").to_model(body, inputs)
    
        dataset = [(torch_tabular_data, targets)]
>       losses = model.fit(dataset, num_epochs=5)

test_model.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../transformers4rec/torch/model/base.py:659: in fit
    print(self.compute_metrics(mode="train"))
../../../transformers4rec/torch/model/base.py:585: in compute_metrics
    metrics.update(head.compute_metrics(mode=mode))
../../../transformers4rec/torch/model/base.py:453: in compute_metrics
    metrics = {
../../../transformers4rec/torch/model/base.py:454: in <dictcomp>
    name_fn(name): task.compute_metrics(mode=mode)
../../../transformers4rec/torch/model/base.py:222: in compute_metrics
    return {self.metric_name(metric): metric.compute() for metric in self.metrics}
../../../transformers4rec/torch/model/base.py:222: in <dictcomp>
    return {self.metric_name(metric): metric.compute() for metric in self.metrics}
/usr/local/lib/python3.8/dist-packages/torchmetrics/metric.py:534: in wrapped_func
    value = compute(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Accuracy()

    def compute(self) -> Tensor:
        """Computes accuracy based on inputs passed in to ``update`` previously."""
        if not self.mode:
>           raise RuntimeError("You have to have determined mode.")
E           RuntimeError: You have to have determined mode.

/usr/local/lib/python3.8/dist-packages/torchmetrics/classification/accuracy.py:616: RuntimeError
-------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------
0it [00:00, ?it/s]1it [00:03,  3.08s/it]1it [00:03,  3.08s/it]
__________________________________________________________ test_model_with_multiple_heads_and_tasks __________________________________________________________

yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
torch_yoochoose_tabular_transformer_features = TabularSequenceFeatures(
  (to_merge): ModuleDict(
    (continuous_module): SequentialBlock(
      (0): ContinuousFeat...ures=256, out_features=100, bias=True)
      (1): ReLU(inplace=True)
    )
  )
  (_masking): CausalLanguageModeling()
)
torch_yoochoose_like = {'category/list': tensor([[ 95, 297,  87,  ...,   0,   0,   0],
        [101, 251, 288,  ...,   0,   0,   0],
        ...43855,
        11013118,  8756821,  2270287,  6761018,  3567838, 11361474,  4069951,
         6787162,  1738605]), ...}

    def test_model_with_multiple_heads_and_tasks(
        yoochoose_schema,
        torch_yoochoose_tabular_transformer_features,
        torch_yoochoose_like,
    ):
        # Tabular classification and regression tasks
        targets = {
            "classification": pytorch.randint(2, (100,)).float(),
            "regression": pytorch.randint(2, (100,)).float(),
        }
    
        non_sequential_features_schema = yoochoose_schema.select_by_name(["user_age", "user_country"])
    
        tabular_features = tr.TabularFeatures.from_schema(
            non_sequential_features_schema,
            max_sequence_length=20,
            continuous_projection=64,
            aggregation="concat",
        )
    
        body = tr.SequentialBlock(tabular_features, tr.MLPBlock([64]))
        tasks = [
            tr.BinaryClassificationTask("classification"),
            tr.RegressionTask("regression"),
        ]
        head_1 = tr.Head(body, tasks)
    
        # Session-based classification and regression tasks
        targets_2 = {
            "classification_session": pytorch.randint(2, (100,)).float(),
            "regression_session": pytorch.randint(2, (100,)).float(),
        }
        transformer_config = tconf.XLNetConfig.build(
            d_model=64, n_head=4, n_layer=2, total_seq_length=20
        )
        body_2 = tr.SequentialBlock(
            torch_yoochoose_tabular_transformer_features,
            tr.MLPBlock([64]),
            tr.TransformerBlock(transformer_config),
        )
        tasks_2 = [
            tr.BinaryClassificationTask("classification_session", summary_type="last"),
            tr.RegressionTask("regression_session", summary_type="mean"),
        ]
        head_2 = tr.Head(body_2, tasks_2)
    
        # Final model with two heads
        model = tr.Model(head_1, head_2)
    
        # get output of the model
        output = model(torch_yoochoose_like)
    
        # launch training
        targets.update(targets_2)
        dataset = [(torch_yoochoose_like, targets)]
        training_args = t4rec.trainer.T4RecTrainingArguments(
                output_dir="./tmp",
                max_sequence_length=20,
                data_loader_engine='nvtabular',
                num_train_epochs=1,
                dataloader_drop_last=False,
                per_device_train_batch_size = 384,
                per_device_eval_batch_size = 512,
                learning_rate=0.0005,
                fp16=True,
                report_to = [],
                logging_steps=200
            )
        recsys_trainer = tr.Trainer(
            model=model,
            args=training_args,
            schema=non_sequential_features_schema,
            compute_metrics=True,
            train_dataset_or_path=dataset,
            eval_dataset_or_path=dataset,
            )
        #TODO:give correct data path
>       recsys_trainer.train()

test_model.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.8/dist-packages/transformers/trainer.py:1115: in train
    train_dataloader = self.get_train_dataloader()
../../../transformers4rec/torch/trainer.py:156: in get_train_dataloader
    return T4RecDataLoader.parse(self.args.data_loader_engine).from_schema(
../../../transformers4rec/torch/utils/data_utils.py:319: in from_schema
    nvt_loader = cls(
../../../transformers4rec/torch/utils/data_utils.py:227: in __init__
    self.set_dataset(buffer_size, engine, reader_kwargs)
../../../transformers4rec/torch/utils/data_utils.py:267: in set_dataset
    dataset = validate_dataset(
../../../merlin_standard_lib/utils/misc_utils.py:239: in validate_dataset
    return Dataset(files, engine=engine, **reader_kwargs)
/usr/local/lib/python3.8/dist-packages/merlin/io/dataset.py:295: in __init__
    paths = sorted(paths, key=natural_sort_key)
/usr/local/lib/python3.8/dist-packages/dask/utils.py:1387: in natural_sort_key
    return [int(part) if part.isdigit() else part for part in re.split(r"(\d+)", s)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pattern = '(\\d+)'
string = ({'category/list': tensor([[ 95, 297,  87,  ...,   0,   0,   0],
        [101, 251, 288,  ...,   0,   0,   0],
       ... 0., 1., 1., 0., 1., 0., 1., 0., 0., 0., 0., 1., 1., 0., 1., 1., 1.,
        1., 0., 0., 1., 0., 1., 0., 0., 0., 1.])})
maxsplit = 0, flags = 0

    def split(pattern, string, maxsplit=0, flags=0):
        """Split the source string by the occurrences of the pattern,
        returning a list containing the resulting substrings.  If
        capturing parentheses are used in pattern, then the text of all
        groups in the pattern are also returned as part of the resulting
        list.  If maxsplit is nonzero, at most maxsplit splits occur,
        and the remainder of the string is returned as the final element
        of the list."""
>       return _compile(pattern, flags).split(string, maxsplit)
E       TypeError: expected string or bytes-like object

/usr/lib/python3.8/re.py:231: TypeError
-------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------
Using amp fp16 backend
--------------------------------------------------------------------- Captured log call ----------------------------------------------------------------------
WARNING  transformers4rec:base.py:87 Masking is set in the input module but not in the TransformerBlock, provide this through the masking argument
_______________________________________________________________ test_set_model_to_device[cpu] ________________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[209,  70,  60,  ...,   0,   0,   0],
        [ 20,  45, 165,  ...,   0,   0,   0],
        ...03164,
        10151174, 10888025,  2804073, 10865882,  4934621,  9928980, 11119436,
         5378603,  2343296]), ...}
torch_yoochoose_next_item_prediction_model = Model(
  (heads): ModuleList(
    (0): Head(
      (body): SequentialBlock(
        (0): TabularSequenceFeatures(
    ... padding_idx=0)
              (log_softmax): LogSoftmax(dim=-1)
            )
          )
        )
      )
    )
  )
)
device = 'cpu'

    @pytest.mark.parametrize("device", devices)
    def test_set_model_to_device(
        torch_yoochoose_like, torch_yoochoose_next_item_prediction_model, device
    ):
        model = torch_yoochoose_next_item_prediction_model
        model.to(device)
    
        assert model.heads[0].body.inputs.masking.masked_item_embedding.device.type == device
        assert next(model.parameters()).device.type == device
    
        inputs = {k: v.to(device) for k, v in torch_yoochoose_like.items()}
>       assert model(inputs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

test_model.py:276: RuntimeError
_______________________________________________________________ test_set_model_to_device[cuda] _______________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[216, 331, 163,  ...,   0,   0,   0],
        [160,  95, 265,  ...,   0,   0,   0],
        ...37194,
          504295,  7520761,  5601010,  7163300, 10987729,  8041138,  9266754,
         2977214,  1035965]), ...}
torch_yoochoose_next_item_prediction_model = Model(
  (heads): ModuleList(
    (0): Head(
      (body): SequentialBlock(
        (0): TabularSequenceFeatures(
    ... padding_idx=0)
              (log_softmax): LogSoftmax(dim=-1)
            )
          )
        )
      )
    )
  )
)
device = 'cuda'

    @pytest.mark.parametrize("device", devices)
    def test_set_model_to_device(
        torch_yoochoose_like, torch_yoochoose_next_item_prediction_model, device
    ):
        model = torch_yoochoose_next_item_prediction_model
        model.to(device)
    
        assert model.heads[0].body.inputs.masking.masked_item_embedding.device.type == device
        assert next(model.parameters()).device.type == device
    
        inputs = {k: v.to(device) for k, v in torch_yoochoose_like.items()}
>       assert model(inputs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

test_model.py:276: RuntimeError
___________________________________________________________ test_eval_metrics_with_masking[causal] ___________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[ 65, 137, 275,  ...,   0,   0,   0],
        [144, 331, 151,  ...,   0,   0,   0],
        ...57677,
         1086422,  8658045,  7724495,  9906659,  9461550,  9775567,  8406967,
         1155855, 10063007]), ...}
yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
masking = 'causal'

    @pytest.mark.parametrize("masking", ["causal", "mlm", "plm", "rtd"])
    def test_eval_metrics_with_masking(torch_yoochoose_like, yoochoose_schema, masking):
        transformer_config = tconf.XLNetConfig.build(64, 4, 2, 20)
        input_module = tr.TabularSequenceFeatures.from_schema(
            yoochoose_schema,
            max_sequence_length=20,
            continuous_projection=64,
            d_output=64,
            masking=masking,
        )
        task = tr.NextItemPredictionTask()
        model = transformer_config.to_torch_model(input_module, task)
        out = model(torch_yoochoose_like)
        result = model.calculate_metrics(
>           inputs=out["predictions"], targets=out["labels"], call_body=False, forward=False
        )
E       IndexError: too many indices for tensor of dimension 2

test_model.py:293: IndexError
____________________________________________________________ test_eval_metrics_with_masking[mlm] _____________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[119,  89, 211,  ..., 221,   0,   0],
        [234, 226, 117,  ...,   0,   0,   0],
        ...84183,
         9725483,  6987470, 11231711,  8898907,  5745734, 10249287,  2008326,
         4413956, 10383378]), ...}
yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
masking = 'mlm'

    @pytest.mark.parametrize("masking", ["causal", "mlm", "plm", "rtd"])
    def test_eval_metrics_with_masking(torch_yoochoose_like, yoochoose_schema, masking):
        transformer_config = tconf.XLNetConfig.build(64, 4, 2, 20)
        input_module = tr.TabularSequenceFeatures.from_schema(
            yoochoose_schema,
            max_sequence_length=20,
            continuous_projection=64,
            d_output=64,
            masking=masking,
        )
        task = tr.NextItemPredictionTask()
        model = transformer_config.to_torch_model(input_module, task)
        out = model(torch_yoochoose_like)
        result = model.calculate_metrics(
>           inputs=out["predictions"], targets=out["labels"], call_body=False, forward=False
        )
E       IndexError: too many indices for tensor of dimension 2

test_model.py:293: IndexError
____________________________________________________________ test_eval_metrics_with_masking[plm] _____________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[117, 227, 232,  ...,   0,   0,   0],
        [123,  52,  36,  ...,   0,   0,   0],
        ...93154,
         5080700,  8337806,  4577159,  6948070,  8632449,  5830146,   810075,
        11544789, 11177580]), ...}
yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
masking = 'plm'

    @pytest.mark.parametrize("masking", ["causal", "mlm", "plm", "rtd"])
    def test_eval_metrics_with_masking(torch_yoochoose_like, yoochoose_schema, masking):
        transformer_config = tconf.XLNetConfig.build(64, 4, 2, 20)
        input_module = tr.TabularSequenceFeatures.from_schema(
            yoochoose_schema,
            max_sequence_length=20,
            continuous_projection=64,
            d_output=64,
            masking=masking,
        )
        task = tr.NextItemPredictionTask()
        model = transformer_config.to_torch_model(input_module, task)
        out = model(torch_yoochoose_like)
        result = model.calculate_metrics(
>           inputs=out["predictions"], targets=out["labels"], call_body=False, forward=False
        )
E       IndexError: too many indices for tensor of dimension 2

test_model.py:293: IndexError
____________________________________________________________ test_eval_metrics_with_masking[rtd] _____________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[254, 197, 243,  ...,   0,   0,   0],
        [321,  92,  24,  ...,  47, 140, 270],
        ...88861,
         6940720,  8841606,  4370491,  9636417, 11037352,  1805523,  9063036,
        10008772,  7417966]), ...}
yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
masking = 'rtd'

    @pytest.mark.parametrize("masking", ["causal", "mlm", "plm", "rtd"])
    def test_eval_metrics_with_masking(torch_yoochoose_like, yoochoose_schema, masking):
        transformer_config = tconf.XLNetConfig.build(64, 4, 2, 20)
        input_module = tr.TabularSequenceFeatures.from_schema(
            yoochoose_schema,
            max_sequence_length=20,
            continuous_projection=64,
            d_output=64,
            masking=masking,
        )
        task = tr.NextItemPredictionTask()
        model = transformer_config.to_torch_model(input_module, task)
        out = model(torch_yoochoose_like)
        result = model.calculate_metrics(
>           inputs=out["predictions"], targets=out["labels"], call_body=False, forward=False
        )
E       IndexError: too many indices for tensor of dimension 2

test_model.py:293: IndexError
_______________________________________________________ test_with_d_model_different_from_item_dim[32] ________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[188, 140, 214,  ...,   0,   0,   0],
        [ 88, 162,   2,  ...,   0,   0,   0],
        ...33164,
        10562935,  9261291,  9725925, 10770441,  1375602, 11386263,  8934249,
         4365906,  8167984]), ...}
yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
d_model = 32

    @pytest.mark.parametrize("d_model", [32, 64, 128])
    def test_with_d_model_different_from_item_dim(torch_yoochoose_like, yoochoose_schema, d_model):
        transformer_config = tconf.XLNetConfig.build(d_model, 4, 2, 20)
        input_module = tr.TabularSequenceFeatures.from_schema(
            yoochoose_schema,
            max_sequence_length=20,
            continuous_projection=64,
            d_output=d_model,
            masking="mlm",
        )
        task = tr.NextItemPredictionTask(weight_tying=True)
        model = transformer_config.to_torch_model(input_module, task)
>       assert model(torch_yoochoose_like)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

test_model.py:310: RuntimeError
--------------------------------------------------------------------- Captured log call ----------------------------------------------------------------------
WARNING  transformers4rec:prediction_task.py:194 Projecting inputs of NextItemPredictionTask to'64' As weight tying requires the input dimension '32' to be equal to the item-id embedding dimension '64'
_______________________________________________________ test_with_d_model_different_from_item_dim[64] ________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[114, 277, 212,  ...,   0,   0,   0],
        [145, 261,  69,  ...,   0,   0,   0],
        ...83586,
        10950377,  6710981,  2951007,  5673063,  7743868, 11492189, 10207866,
         1084276, 11198688]), ...}
yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
d_model = 64

    @pytest.mark.parametrize("d_model", [32, 64, 128])
    def test_with_d_model_different_from_item_dim(torch_yoochoose_like, yoochoose_schema, d_model):
        transformer_config = tconf.XLNetConfig.build(d_model, 4, 2, 20)
        input_module = tr.TabularSequenceFeatures.from_schema(
            yoochoose_schema,
            max_sequence_length=20,
            continuous_projection=64,
            d_output=d_model,
            masking="mlm",
        )
        task = tr.NextItemPredictionTask(weight_tying=True)
        model = transformer_config.to_torch_model(input_module, task)
>       assert model(torch_yoochoose_like)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

test_model.py:310: RuntimeError
_______________________________________________________ test_with_d_model_different_from_item_dim[128] _______________________________________________________

torch_yoochoose_like = {'category/list': tensor([[289,  72, 231,  ...,   0,   0,   0],
        [237, 291, 193,  ..., 288, 292, 187],
        ...60673,
         2996333,  7469160,  7785203,  5478241,  9740876,  2277348, 10898197,
         2598702,   465083]), ...}
yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
d_model = 128

    @pytest.mark.parametrize("d_model", [32, 64, 128])
    def test_with_d_model_different_from_item_dim(torch_yoochoose_like, yoochoose_schema, d_model):
        transformer_config = tconf.XLNetConfig.build(d_model, 4, 2, 20)
        input_module = tr.TabularSequenceFeatures.from_schema(
            yoochoose_schema,
            max_sequence_length=20,
            continuous_projection=64,
            d_output=d_model,
            masking="mlm",
        )
        task = tr.NextItemPredictionTask(weight_tying=True)
        model = transformer_config.to_torch_model(input_module, task)
>       assert model(torch_yoochoose_like)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

test_model.py:310: RuntimeError
--------------------------------------------------------------------- Captured log call ----------------------------------------------------------------------
WARNING  transformers4rec:prediction_task.py:194 Projecting inputs of NextItemPredictionTask to'64' As weight tying requires the input dimension '128' to be equal to the item-id embedding dimension '64'
____________________________________________________________ test_output_shape_mode_eval[causal] _____________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[199,  76, 147,  ...,   0,   0,   0],
        [151, 254, 276,  ...,   0,   0,   0],
        ...44899,
         6322940,  4566426,  9257042,  2811213, 10261896,  7155283,  7312102,
         1177582,   891361]), ...}
yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
masking = 'causal'

    @pytest.mark.parametrize("masking", ["causal", "mlm", "plm", "rtd"])
    def test_output_shape_mode_eval(torch_yoochoose_like, yoochoose_schema, masking):
        input_module = tr.TabularSequenceFeatures.from_schema(
            yoochoose_schema,
            max_sequence_length=20,
            d_output=64,
            masking=masking,
        )
        prediction_task = tr.NextItemPredictionTask(weight_tying=True)
        transformer_config = tconf.XLNetConfig.build(
            d_model=64, n_head=8, n_layer=2, total_seq_length=20
        )
        model = transformer_config.to_torch_model(input_module, prediction_task)
    
        out = model(torch_yoochoose_like, training=False)
>       assert out["predictions"].shape[0] == torch_yoochoose_like["item_id/list"].size(0)
E       IndexError: too many indices for tensor of dimension 2

test_model.py:328: IndexError
______________________________________________________________ test_output_shape_mode_eval[mlm] ______________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[ 65, 110, 147,  ...,   0,   0,   0],
        [ 38, 117, 280,  ...,  60,  23, 329],
        ...98640,
         7351364,  6803955,  3477018,  5581723,  3577299,  9869113,  5447139,
        10088356,  1681984]), ...}
yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
masking = 'mlm'

    @pytest.mark.parametrize("masking", ["causal", "mlm", "plm", "rtd"])
    def test_output_shape_mode_eval(torch_yoochoose_like, yoochoose_schema, masking):
        input_module = tr.TabularSequenceFeatures.from_schema(
            yoochoose_schema,
            max_sequence_length=20,
            d_output=64,
            masking=masking,
        )
        prediction_task = tr.NextItemPredictionTask(weight_tying=True)
        transformer_config = tconf.XLNetConfig.build(
            d_model=64, n_head=8, n_layer=2, total_seq_length=20
        )
        model = transformer_config.to_torch_model(input_module, prediction_task)
    
        out = model(torch_yoochoose_like, training=False)
>       assert out["predictions"].shape[0] == torch_yoochoose_like["item_id/list"].size(0)
E       IndexError: too many indices for tensor of dimension 2

test_model.py:328: IndexError
______________________________________________________________ test_output_shape_mode_eval[plm] ______________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[168,  45,  42,  ...,   0,   0,   0],
        [288,  43, 174,  ..., 288, 110, 162],
        ...25654,
         2468836,  9668183,   467847,   995949,  3911354,  4206847,  3375374,
         2700013,  6277962]), ...}
yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
masking = 'plm'

    @pytest.mark.parametrize("masking", ["causal", "mlm", "plm", "rtd"])
    def test_output_shape_mode_eval(torch_yoochoose_like, yoochoose_schema, masking):
        input_module = tr.TabularSequenceFeatures.from_schema(
            yoochoose_schema,
            max_sequence_length=20,
            d_output=64,
            masking=masking,
        )
        prediction_task = tr.NextItemPredictionTask(weight_tying=True)
        transformer_config = tconf.XLNetConfig.build(
            d_model=64, n_head=8, n_layer=2, total_seq_length=20
        )
        model = transformer_config.to_torch_model(input_module, prediction_task)
    
        out = model(torch_yoochoose_like, training=False)
>       assert out["predictions"].shape[0] == torch_yoochoose_like["item_id/list"].size(0)
E       IndexError: too many indices for tensor of dimension 2

test_model.py:328: IndexError
______________________________________________________________ test_output_shape_mode_eval[rtd] ______________________________________________________________

torch_yoochoose_like = {'category/list': tensor([[318, 160, 307,  ...,   0,   0,   0],
        [ 43, 148, 165,  ...,   0,   0,   0],
        ...57115,
        11311926,  1316468, 10350507, 11442892,  7753894,  7538651,  5934226,
         5616004,  9385786]), ...}
yoochoose_schema = [{'name': 'session_id', 'type': 'INT', 'int_domain': {'name': 'session_id', 'min': '1', 'max': '11562158'}, 'annotatio...ype': 'FLOAT', 'float_domain': {'name': 'user_age', 'max': 0.4079650044441223}, 'annotation': {'tag': ['continuous']}}]
masking = 'rtd'

    @pytest.mark.parametrize("masking", ["causal", "mlm", "plm", "rtd"])
    def test_output_shape_mode_eval(torch_yoochoose_like, yoochoose_schema, masking):
        input_module = tr.TabularSequenceFeatures.from_schema(
            yoochoose_schema,
            max_sequence_length=20,
            d_output=64,
            masking=masking,
        )
        prediction_task = tr.NextItemPredictionTask(weight_tying=True)
        transformer_config = tconf.XLNetConfig.build(
            d_model=64, n_head=8, n_layer=2, total_seq_length=20
        )
        model = transformer_config.to_torch_model(input_module, prediction_task)
    
        out = model(torch_yoochoose_like, training=False)
>       assert out["predictions"].shape[0] == torch_yoochoose_like["item_id/list"].size(0)
E       IndexError: too many indices for tensor of dimension 2

test_model.py:328: IndexError
____________________________________________________________ test_save_next_item_prediction_model ____________________________________________________________

torch_yoochoose_tabular_transformer_features = TabularSequenceFeatures(
  (to_merge): ModuleDict(
    (continuous_module): SequentialBlock(
      (0): ContinuousFeat...ures=256, out_features=100, bias=True)
      (1): ReLU(inplace=True)
    )
  )
  (_masking): CausalLanguageModeling()
)
torch_yoochoose_like = {'category/list': tensor([[ 38, 108, 292,  ..., 200, 145,   0],
        [302, 201, 243,  ...,   0,   0,   0],
        ...66119,
         9968101,  2629057,  9679119,  9256068,  2828910,  2425823,  7597517,
         3992448,  7743949]), ...}

    def test_save_next_item_prediction_model(
        torch_yoochoose_tabular_transformer_features, torch_yoochoose_like
    ):
        inputs = torch_yoochoose_tabular_transformer_features
        transformer_config = tconf.XLNetConfig.build(100, 4, 2, 20)
        task = tr.NextItemPredictionTask(weight_tying=True)
        model = transformer_config.to_torch_model(inputs, task)
        output = model(torch_yoochoose_like, training=False)
>       assert isinstance(output, dict)
E       assert False
E        +  where False = isinstance(tensor([[-10.7595, -10.7622, -10.6539,  ..., -11.0835, -11.2931, -10.8045],\n        [-10.7888, -10.7378, -10.7701,  .....17],\n        [-10.7031, -10.8597, -10.8620,  ..., -10.8657, -11.2464, -10.7707]],\n       grad_fn=<LogSoftmaxBackward0>), dict)

test_model.py:339: AssertionError
--------------------------------------------------------------------- Captured log call ----------------------------------------------------------------------
WARNING  transformers4rec:prediction_task.py:194 Projecting inputs of NextItemPredictionTask to'64' As weight tying requires the input dimension '100' to be equal to the item-id embedding dimension '64'
====================================================================== warnings summary ======================================================================
tests/torch/model/test_model.py::test_simple_model
  /usr/local/lib/python3.8/dist-packages/torchmetrics/utilities/prints.py:36: UserWarning: The ``compute`` method of metric Precision was called before the ``update`` method which may lead to errors, as metric states have not yet been updated.
    warnings.warn(*args, **kwargs)

tests/torch/model/test_model.py::test_simple_model
  /usr/local/lib/python3.8/dist-packages/torchmetrics/utilities/prints.py:36: UserWarning: The ``compute`` method of metric Recall was called before the ``update`` method which may lead to errors, as metric states have not yet been updated.
    warnings.warn(*args, **kwargs)

tests/torch/model/test_model.py::test_simple_model
  /usr/local/lib/python3.8/dist-packages/torchmetrics/utilities/prints.py:36: UserWarning: The ``compute`` method of metric Accuracy was called before the ``update`` method which may lead to errors, as metric states have not yet been updated.
    warnings.warn(*args, **kwargs)

tests/torch/model/test_model.py::test_model_with_multiple_heads_and_tasks
  /usr/local/lib/python3.8/dist-packages/nvtabular/io.py:23: DeprecationWarning: The `nvtabular.io` module has moved to `merlin.io`. Support for importing from `nvtabular.io` is deprecated, and will be removed in a future version. Please update your imports to refer to `merlin.io`.
    warnings.warn(

tests/torch/model/test_model.py::test_item_prediction_transformer_torch_model_from_config[XLNetConfig]
tests/torch/model/test_model.py::test_item_prediction_transformer_torch_model_from_config[AlbertConfig]
tests/torch/model/test_model.py::test_item_prediction_transformer_torch_model_from_config[LongformerConfig]
tests/torch/model/test_model.py::test_item_prediction_transformer_torch_model_from_config[GPT2Config]
  /usr/local/lib/python3.8/dist-packages/merlin/schema/tags.py:148: UserWarning: Compound tags like Tags.ITEM_ID have been deprecated and will be removed in a future version. Please use the atomic versions of these tags, like [<Tags.ITEM: 'item'>, <Tags.ID: 'id'>].
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================================================== short test summary info ===================================================================
FAILED test_model.py::test_simple_model - RuntimeError: You have to have determined mode.
FAILED test_model.py::test_model_with_multiple_heads_and_tasks - TypeError: expected string or bytes-like object
FAILED test_model.py::test_set_model_to_device[cpu] - RuntimeError: Boolean value of Tensor with more than one value is ambiguous
FAILED test_model.py::test_set_model_to_device[cuda] - RuntimeError: Boolean value of Tensor with more than one value is ambiguous
FAILED test_model.py::test_eval_metrics_with_masking[causal] - IndexError: too many indices for tensor of dimension 2
FAILED test_model.py::test_eval_metrics_with_masking[mlm] - IndexError: too many indices for tensor of dimension 2
FAILED test_model.py::test_eval_metrics_with_masking[plm] - IndexError: too many indices for tensor of dimension 2
FAILED test_model.py::test_eval_metrics_with_masking[rtd] - IndexError: too many indices for tensor of dimension 2
FAILED test_model.py::test_with_d_model_different_from_item_dim[32] - RuntimeError: Boolean value of Tensor with more than one value is ambiguous
FAILED test_model.py::test_with_d_model_different_from_item_dim[64] - RuntimeError: Boolean value of Tensor with more than one value is ambiguous
FAILED test_model.py::test_with_d_model_different_from_item_dim[128] - RuntimeError: Boolean value of Tensor with more than one value is ambiguous
FAILED test_model.py::test_output_shape_mode_eval[causal] - IndexError: too many indices for tensor of dimension 2
FAILED test_model.py::test_output_shape_mode_eval[mlm] - IndexError: too many indices for tensor of dimension 2
FAILED test_model.py::test_output_shape_mode_eval[plm] - IndexError: too many indices for tensor of dimension 2
FAILED test_model.py::test_output_shape_mode_eval[rtd] - IndexError: too many indices for tensor of dimension 2
FAILED test_model.py::test_save_next_item_prediction_model - assert False
========================================================= 16 failed, 11 passed, 8 warnings in 14.71s =========================================================
